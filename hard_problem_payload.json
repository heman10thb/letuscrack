{
    "title": "Median of Two Sorted Arrays",
    "slug": "median-of-two-sorted-arrays-api",
    "description": "Find the median of two sorted arrays of distinct sizes.",
    "category_id": "68df36b8-e3ce-420e-a210-3a0091afa7ec",
    "difficulty": "hard",
    "problem_statement": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return the median of the two sorted arrays.</p><p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>",
    "constraints": "<ul><li>nums1.length == m</li><li>nums2.length == n</li><li>0 <= m <= 1000</li><li>0 <= n <= 1000</li><li>1 <= m + n <= 2000</li><li>-10^6 <= nums1[i], nums2[i] <= 10^6</li></ul>",
    "input_format": "<p>Two sorted integer arrays.</p>",
    "output_format": "<p>A float representing the median.</p>",
    "examples": [
        {
            "input": "nums1 = [1,3], nums2 = [2]",
            "output": "2.00000",
            "explanation": "merged array = [1,2,3] and median is 2."
        },
        {
            "input": "nums1 = [1,2], nums2 = [3,4]",
            "output": "2.50000",
            "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        }
    ],
    "solutions": {
        "python": {
            "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            return self.findMedianSortedArrays(nums2, nums1)\n        \n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        \n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n            \n            maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minX = float('inf') if partitionX == x else nums1[partitionX]\n            \n            maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minY = float('inf') if partitionY == y else nums2[partitionY]\n            \n            if maxX <= minY and maxY <= minX:\n                if (x + y) % 2 == 0:\n                    return (max(maxX, maxY) + min(minX, minY)) / 2\n                else:\n                    return max(maxX, maxY)\n            elif maxX > minY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1",
            "explanation": "<p>Binary Search on the smaller array partition.</p>",
            "time_complexity": "O(log(min(m,n)))",
            "space_complexity": "O(1)"
        },
        "cpp": {
            "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int x = nums1.size();\n        int y = nums2.size();\n        int low = 0, high = x;\n        \n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n            \n            int maxX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n            int minX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n            \n            int maxY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n            int minY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n            \n            if (maxX <= minY && maxY <= minX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double)max(maxX, maxY) + min(minX, minY)) / 2;\n                } else {\n                    return (double)max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        return 0.0;\n    }\n};",
            "explanation": "<p>Partitioning approach using Binary Search.</p>",
            "time_complexity": "O(log(min(m,n)))",
            "space_complexity": "O(1)"
        },
        "java": {
            "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int x = nums1.length;\n        int y = nums2.length;\n        int low = 0, high = x;\n        \n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n            \n            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n            \n            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n            \n            if (maxX <= minY && maxY <= minX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n                } else {\n                    return (double)Math.max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        return 0.0;\n    }\n}",
            "explanation": "<p>Similar recursive binary search logic.</p>",
            "time_complexity": "O(log(min(m,n)))",
            "space_complexity": "O(1)"
        },
        "javascript": {
            "code": "var findMedianSortedArrays = function(nums1, nums2) {\n    if (nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1);\n    \n    let x = nums1.length;\n    let y = nums2.length;\n    let low = 0, high = x;\n    \n    while (low <= high) {\n        let partitionX = Math.floor((low + high) / 2);\n        let partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        let maxX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        let minX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        let maxY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        let minY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxX <= minY && maxY <= minX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n};",
            "explanation": "<p>Implemented using Binary Search for O(log(min(m,n))).</p>",
            "time_complexity": "O(log(min(m,n)))",
            "space_complexity": "O(1)"
        }
    },
    "status": "published",
    "approach": "<p>The brute force way is to merge the two arrays and find the median, but that takes O(m+n). The optimal approach uses binary search to partition the two arrays such that the left half has the same number of elements as the right half.</p>",
    "diagram": {
        "chart": "flowchart TD\n    A[Start] --> B{len(nums1) > len(nums2)?}\n    B -- Yes --> C[Swap nums1, nums2]\n    B -- No --> D[Binary Search on nums1]\n    D --> E{Found Partition?}\n    E -- No --> F[Adjust low/high]\n    E -- Yes --> G[Calculate Median]",
        "title": "Median Search Logic",
        "explanation": "<p>Ensures we always binary search the smaller array.</p>"
    },
    "time_complexity": "O(log(min(m,n)))",
    "space_complexity": "O(1)"
}